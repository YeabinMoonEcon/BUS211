---
title: "Lecture 6"
author: "Yeabin Moon"
date: "2022-09-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gapminder)
```

# Understanding ggplot (continued)

We will continue to develop our understanding of ggplot. You should be familiar with the baseline property to proceed.

When you practice coding, you will encounter a lot of errors. The error message seems to be mysterious, but it is not random. We have already seen a few problems when an aesthetic is mistakenly set to a constant value instead of being mapped to a variable. 

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = "pink"))
p + geom_point() + geom_smooth(method = "loess") + scale_x_log10()
```
In this lecture, we will discuss some useful features of ggplot that also commonly cause trouble.

Some keywords you need to know:

- grouping
- faceting
- transforming

The ggplot library is an implementation of the <em>Grammar of graphics</em>, an idea developed by Wilkinson (2005). It consists of several rules. If you break a rule, it will throw an error without any result. For example, you omitted + sign between ggplot object and geom_ functions. It is usually referred to as syntax error, which is easily captured. Other times, you made mistakes in your codes, but the codes did not break any rules. Or you might use wrong information, for example, different column inputs. How could we handle them?

Let's see some common errors.

## 1. group argument in aes()
Go back to gapminder dataset. Suppose I want to each country's GDP per capita by time. We have year, lifeExp, and country variables, so running 
```
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))
p + geom_line() 
```
would provide the general trend line. Let's see:
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))
p + geom_line() 
```
<br>
You can guess what geom_line() does from:
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))
p + geom_point() 

gapminder %>% arrange(year) %>% head(10)

```
<br>
While ggplot will make a pretty good guess as to the structure of the data, it does not know that the yearly observations in the data are grouped by country. We have to tell it. In fact, geom_line() starts with observation in 1952 in the first row of data and joins all 1952 data.

When you produce a plot but it looks weird, the problem is most likely in the mapping between the data and aesthetics for the geom_ being used. 

In this case, we can use the group argument in aes() to tell ggplot explicitly about this structure.
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))
p + geom_line(aes(group = country)) 
```
<br>
It looks rough, but you will see that each line represents country's

Think about what's happening here?:
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))
p + geom_line(aes(group = continent)) 
```

## 2. Facet: multi plots
The last plot would be the one, but it is messy. Creating multiple plots in one panel would help. It would allow a lot of information to be compactly and comparably presented. This is called faceting data by some other variables. We have continent variable, which splits the data into 5.    

The facet_wrap() function can take a series of arguments, but the most important is the first one. 
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))
p + geom_line(aes(group = country))  + facet_wrap(~ continent)
```
<br>
~, tilde, is used for a formula in R syntax, and facets have only one side. Most of the time, you will just want a single variable on the right side of the formula.

Each facet is labeled at the top. The overall layout minimizes the duplication of axis labels and other scales. In fact, we can add the features we have learned in each facet. Let's develop:
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))
p + geom_line(aes(group = country), color = "honeydew3")  + 
    facet_wrap(~ continent, ncol = 5)
# see where color argument is located!
# what's the role of ncol argument?
```
<br>Add smoother
```{r}
p + geom_line(aes(group = country), color = "honeydew3")  + 
    facet_wrap(~ continent, ncol = 5) +
    geom_smooth(size = 1 , method = "loess", se = FALSE)
# check out the arguments in geom_smooth
```
<br>Scale 
```{r}
p + geom_line(aes(group = country), color = "honeydew3")  + 
    facet_wrap(~ continent, ncol = 5) +
    geom_smooth(size = 1 , method = "loess", se = FALSE) +
    scale_y_log10(labels=scales::dollar)
```
<br>Add labels
```{r}
p + geom_line(aes(group = country), color = "honeydew3")  + 
    facet_wrap(~ continent, ncol = 3) +
    geom_smooth(size = 1 , method = "loess", se = FALSE) +
    scale_y_log10(labels=scales::dollar) +
    labs(x = "Year", y = "GDP per capita", title = "GDP per capita on Five Continents")
```

The facet_wrap() function is best used when you want a series of small multiples based on a single categorical variable. Your panels will be laid out in order and then wrapped into a grid.

facet_grid() might be useful when you want to facet your data more than 2 categorical variables. See the <a href="https://ggplot2.tidyverse.org/reference/facet_grid.html" target="_blank">Link</a>. Let's use another datafile. The following command would throw an error in your machine: why?
```{r}
setwd("~/Documents/ibs_course/BUS240/data")
load('gss_sm.rda')
head(gss_sm, 10)
```
This is a sample of the General Social Survey in 2016. Compared to gapminder, this data set contains many categorical variables. Play it around what information is available. 

See the following: 
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = age, y = childs))
p + geom_point() 
```

It would indicate the relationship between the age of the respondent and the number of children they have. We will then facet this relationship by sex and race of the respondent. 
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = age, y = childs))
p + geom_point()+facet_grid(sex ~ race)
```
<br>Add details on scatterplat
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = age, y = childs))
p + geom_point(alpha = .3)+facet_grid(sex ~ race) + geom_smooth()
```


## 3. When Mapping is not clear
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion))
p + geom_bar()
```

There is only one mapping here. Note the y-axis. count is not in the data set. In fact, geom_bar() calls the stat_count() inside and calculate the number of count for the corresponding values. This function also calculates the proportion.  

```{r}
p + geom_bar(mapping = aes(y = ..prop..))
```

Ignore the figure now and just see how we access to the inside operations. We need to put the prop
 statistic. When ggplot calculates the count or the proportion, it returns temporary variables that we can use as mappings in our plots. To make sure these temporary variables won’t be confused with others we are working with, it should be mapping = ..statistic..

But still the figure looks not right. This is because of grouping.  

```{r}
p + geom_bar(mapping = aes(y = ..prop.., group = 2))
```

We need to force ggplot to use whole dataset instead of x-categories when calculating proportions.
group = 'pink' is just a kind of “dummy group”. You can use anything, for example group = 2, creating a dummy.

Color?
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, color = bigregion))
p + geom_bar()
```

Note that fill is for painting the insides of shapes (remember ribbons?). 
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = bigregion))
p + geom_bar()
```

## 4. More on fill

Take a look
```{r}
table(gss_sm$region)
```

Consider we want to look at religious preference by census region. You might recall the color argument in aes. Good, but we need to use fill.

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))
p + geom_bar()
```

Note that region of the country is on the x-axis, and counts of religious preference are stacked within the bars. 

To see the relative share:
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))
p + geom_bar(position = 'fill')
```

Note that the position argument in geom_bar() to "fill" which is not the same argument in aes().

What if we want to show the separate bars instead of showing the stacked?
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))
p + geom_bar(position = 'dodge')
```

To convert it to see the proportions, 
```{r}
p + geom_bar(position = 'dodge',
             mapping = aes(y = ..prop..))
```
```{r}
p + geom_bar(position = 'dodge',
             mapping = aes(y = ..prop.., group = religion))
```
When we just wanted the overall proportions for one variable, we mapped group = 1 to tell ggplot to calculate the proportions with respect to the overall N. In this case our grouping variable is religion, so we might try mapping that to the group aesthetic.

Or you can let facet function do the work
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = religion))
p + geom_bar(position = "dodge", mapping = aes(y = ..prop.., group = bigregion)) +
    facet_wrap(~ bigregion, ncol = 2)
```

## 5. Do not confuse with Histogram
What is a histogram?
```{r}
head(midwest, 10)
```
midwest is a pre-installed dataset in ggplot, including information on counties in the midwest.

```{r}
p <- ggplot(data = midwest, mapping = aes(x = area))
p + geom_histogram()
p + geom_histogram(bins = 10)
```

While histograms summarize single variables, it's also possible to use several at once to compare distributions. We can facet histograms by some variable of interest, or as here we can compare them in the same plot using fill().

```{r}
two_states <- c("IL", "MI")

p <- ggplot(data = subset(midwest, subset = state %in% two_states),
            mapping = aes(x = percollege, fill = state))
p + geom_histogram(alpha = 0.4, bins = 20)
```

We subset the data here to pick out just two states. Here, illinois and Michigan. Then we use the subset() function to take our data and filter it so that we only select rows whose state name is in this vector. The %in% operator is a convenient way to filter on more than one term in a variable when using subset().

We can similarly build a density function.
```{r}
p <- ggplot(data = midwest, mapping = aes(x = area))
p + geom_density()
```
```{r}
p <- ggplot(data = midwest, mapping = aes(x = area, fill = state, color = state))
p + geom_density(alpha = 0.3)
```
```{r}
p <- ggplot(data = subset(midwest, subset = state %in% two_states),
            mapping = aes(x = area, fill = state, color = state))
p + geom_density(alpha = 0.3, mapping = (aes(y = ..scaled..)))
```

## 6. Plot summary table
```{r}
setwd("~/Documents/ibs_course/BUS240/data")
load('titanic.rda')
head(titanic, 10)

p <- ggplot(data = titanic, mapping = aes(x = fate, y = percent, fill = sex))
#p + geom_bar(position = "dodge")

p + geom_bar(position = "dodge", stat = "identity")
```